#include<cstring>
#include<stdio.h>
#include<algorithm>
#include<iostream>
#include<unordered_map>
#include<map>
#include<cstdlib>
#include<ctime>
#include<cmath>
#include<cstdlib>
#include<bitset>
#define X 3
#define Y 6
#define NUM 3
#define LIMIT 16
#define min(a,b) a<=b?a:b
#define max(a,b) a>b?a:b
typedef long long ll;
typedef double d;
const ll mod=10993 ;
const int RANGE=5000003;
const int R2=10000031;
using namespace std;
const char c[]= {'A','G','C','T'};

d vals[][4]={ 
{ 1 , 1 , 1 , 1 }, { 2 , 2.35 , 2.7 , 2.55 }, { 3 , 4.6 , 5.1 , 5.5 }, { 4 , 6.9 , 7.75 , 8.35 }, { 5 , 9.7 , 12.15 , 13.05 }, { 6 , 14.05 , 16.6 , 17.9 }, { 7 , 18.85 , 22.65 , 23.75 }, { 8 , 24.9 , 28.75 , 30.1 }, { 9 , 29.35 , 35.25 , 38.05 }, { 10 , 36.8 , 43.7 , 46.25 }, { 11 , 46 , 53.85 , 55.45 }, { 12 , 53.05 , 61.9 , 66.6 }, { 13 , 63.5 , 73.6 , 76.8 }, { 14 , 75.3 , 84.7 , 90.65 }, { 15 , 85.6 , 98.1 , 102 }, { 2 , 2.2 , 2.55 , 2.7 }, { 4 , 6.5 , 7 , 7.3 }, { 6 , 11.65 , 13.65 , 14.95 }, { 8 , 19.35 , 22.2 , 24.4 }, { 10 , 27.95 , 33.45 , 35.95 }, { 12 , 37.4 , 47.55 , 50.95 }, { 14 , 51.2 , 63.25 , 68.1 }, { 16 , 68.75 , 83.2 , 89.3 }, { 18 , 85.85 , 105.1 , 112.05 }, { 20 , 107.4 , 126.7 , 137.5 }, { 22 , 129.85 , 153.9 , 164.25 }, { 24 , 158.75 , 187.15 , 198.25 }, { 26 , 184.3 , 217.05 , 230 }, { 28 , 214.1 , 252.7 , 269.7 }, { 30 , 249.85 , 289.25 , 306.7 }, { 3 , 4.7 , 5.15 , 4.95 }, { 6 , 11.65 , 13.7 , 14.6 }, { 9 , 22.9 , 27.7 , 28.9 }, { 12 , 35.4 , 44.55 , 48.55 }, { 15 , 55.45 , 66.9 , 71.95 }, { 18 , 78.1 , 94.65 , 100.25 }, { 21 , 105.5 , 126.8 , 136.8 }, { 24 , 134.65 , 164.8 , 176.3 }, { 27 , 174.7 , 208.05 , 222.55 }, { 30 , 215.1 , 253.95 , 271.15 }, { 33 , 262.65 , 310.4 , 326.9 }, { 36 , 312.5 , 370.75 , 394.95 }, { 39 , 373.2 , 435.5 , 463.5 }, { 42 , 427.4 , 508.5 , 535 }, { 45 , 505.4 , 584.5 , 617.25 }, { 4 , 7.5 , 8.15 , 8.75 }, { 8 , 18.6 , 22.05 , 24.3 }, { 12 , 37 , 43.65 , 47.05 }, { 16 , 59.35 , 74.25 , 80.85 }, { 20 , 90.95 , 111.35 , 120.05 }, { 24 , 126.1 , 158.4 , 170.35 }, { 28 , 175 , 210.95 , 226.7 }, { 32 , 228.4 , 275.9 , 296.1 }, { 36 , 289.65 , 346.5 , 372.7 }, { 40 , 358.95 , 433.75 , 458.85 }, { 44 , 443.45 , 515.8 , 552.6 }, { 48 , 530.7 , 621.2 , 660.1 }, { 52 , 627.85 , 730.7 , 774.25 }, { 56 , 736.3 , 849.4 , 896.05 }, { 60 , 845.45 , 982.3 , 1031.15 }, { 5 , 10.15 , 12.2 , 13 }, { 10 , 26.55 , 32.75 , 36.05 }, { 15 , 55.25 , 66.65 , 70.85 }, { 20 , 90.15 , 110.65 , 120.1 }, { 25 , 139.15 , 165.5 , 183.15 }, { 30 , 194.85 , 239.8 , 255.95 }, { 35 , 265.3 , 320.4 , 342.55 }, { 40 , 348.1 , 417.45 , 447.15 }, { 45 , 446 , 527.5 , 562.4 }, { 50 , 538.8 , 633.15 , 669.8 }, { 55 , 671.7 , 787.85 , 837.7 }, { 60 , 808.4 , 946.75 , 994.35 }, { 65 , 958.5 , 1105.15 , 1172.65 }, { 70 , 1112.85 , 1293.85 , 1357 }, { 75 , 1292.5 , 1488.5 , 1561.45 }, { 6 , 13.8 , 17.05 , 18 }, { 12 , 38.75 , 47.6 , 50.9 }, { 18 , 77.6 , 93.7 , 101.25 }, { 24 , 130.7 , 158.35 , 168.7 }, { 30 , 195.1 , 238.15 , 257.1 }, { 36 , 280.1 , 341.05 , 360.75 }, { 42 , 378.25 , 453.1 , 487.3 }, { 48 , 496.6 , 588 , 624.5 }, { 54 , 635.7 , 747.85 , 799.65 }, { 60 , 786.5 , 924.8 , 979.5 }, { 66 , 954.8 , 1120.65 , 1184.4 }, { 72 , 1142.15 , 1330.5 , 1399.05 }, { 78 , 1362.95 , 1568.6 , 1652.95 }, { 84 , 1594.9 , 1826.7 , 1915.6 }, { 90 , 1837.5 , 2103.45 , 2200.95 }, { 7 , 19.1 , 21.75 , 23.9 }, { 14 , 51.9 , 62.9 , 66.85 }, { 21 , 105.25 , 127.8 , 135.15 }, { 28 , 175.8 , 213.05 , 227.7 }, { 35 , 267.15 , 319 , 345.7 }, { 42 , 371.35 , 451.95 , 484.5 }, { 49 , 511 , 607.95 , 651.8 }, { 56 , 675.95 , 798.3 , 849.3 }, { 63 , 857.05 , 1009.45 , 1068.4 }, { 70 , 1058.5 , 1249.4 , 1318.15 }, { 77 , 1292.95 , 1510.3 , 1588.35 }, { 84 , 1555.6 , 1800.2 , 1886.85 }, { 91 , 1818.2 , 2071.8 , 2175.5 }, { 98 , 2155.25 , 2447.5 , 2570.85 }, { 105 , 2492.6 , 2819.75 , 2944.25 }, { 8 , 25.7 , 28 , 30.65 }, { 16 , 67.75 , 82.8 , 89 }, { 24 , 138.15 , 164.35 , 176.7 }, { 32 , 225.6 , 276.55 , 296.85 }, { 40 , 349.65 , 418.3 , 445.85 }, { 48 , 492.25 , 592.6 , 632.85 }, { 56 , 672.5 , 796.05 , 850.7 }, { 64 , 878.7 , 1039.9 , 1101.75 }, { 72 , 1119.55 , 1310.1 , 1383.3 }, { 80 , 1386.4 , 1620.75 , 1705.9 }, { 88 , 1703.8 , 1962.85 , 2057.9 }, { 96 , 2037.2 , 2333.5 , 2443.55 }, { 104 , 2385.7 , 2721.3 , 2845.25 }, { 112 , 2813 , 3185.1 , 3314.8 }, { 120 , 3242.65 , 3655.7 , 3813.7 }, { 9 , 29.85 , 35.5 , 37.45 }, { 18 , 87.6 , 102.05 , 110.9 }, { 27 , 173.3 , 207.85 , 224.1 }, { 36 , 291.8 , 348.35 , 372.5 }, { 45 , 445.75 , 531.9 , 563.65 }, { 54 , 630.3 , 743.3 , 799.25 }, { 63 , 857.3 , 1011.2 , 1067.55 }, { 72 , 1116.35 , 1314.15 , 1387.4 }, { 81 , 1433.45 , 1657.7 , 1744.75 }, { 90 , 1771.6 , 2045.2 , 2143.85 }, { 99 , 2152.35 , 2470.1 , 2586.2 }, { 108 , 2569.35 , 2942.8 , 3080.95 }, { 117 , 3038.1 , 3438.8 , 3577.45 }, { 126 , 3537.1 , 3999.6 , 4163.65 }, { 135 , 4096.15 , 4607.55 , 4788.6 }, { 10 , 37.65 , 43.6 , 46.35 }, { 20 , 109.95 , 129 , 137.25 }, { 30 , 215.05 , 256.1 , 272.6 }, { 40 , 363.05 , 431.5 , 456.9 }, { 50 , 550.1 , 650.8 , 695.9 }, { 60 , 789.5 , 925.65 , 978.4 }, { 70 , 1072.75 , 1248.1 , 1315.95 }, { 80 , 1398.45 , 1623.45 , 1712.7 }, { 90 , 1768.55 , 2044.7 , 2145.3 }, { 100 , 2192.2 , 2516.45 , 2630.65 }, { 110 , 2671.65 , 3039.2 , 3188.7 }, { 120 , 3198.05 , 3632.55 , 3789.1 }, { 130 , 3769.75 , 4250.6 , 4435.9 }, { 140 , 4409.2 , 4960.75 , 5149.35 }, { 150 , 5083.4 , 5684.5 , 5896.8 }, { 11 , 45 , 52.55 , 56.7 }, { 22 , 131.5 , 154.9 , 164.7 }, { 33 , 263.2 , 307.8 , 331.5 }, { 44 , 438.85 , 519.5 , 554.85 }, { 55 , 671.45 , 787.95 , 835.4 }, { 66 , 957.7 , 1115.65 , 1180 }, { 77 , 1290.75 , 1507.4 , 1590.5 }, { 88 , 1693.95 , 1961.2 , 2058.4 }, { 99 , 2140.9 , 2469.95 , 2590 }, { 110 , 2670.15 , 3042.75 , 3175.15 }, { 121 , 3253.4 , 3684.75 , 3837.7 }, { 132 , 3878.35 , 4380.05 , 4559 }, { 143 , 4583.65 , 5148.85 , 5347.75 }, { 154 , 5337 , 5978.35 , 6199.65 }, { 165 , 6181.45 , 6862 , 7116.5 }, { 12 , 54.05 , 62.5 , 66.9 }, { 24 , 155.15 , 186.35 , 195.1 }, { 36 , 313.4 , 369.4 , 394.25 }, { 48 , 529.8 , 624.95 , 660.55 }, { 60 , 804.4 , 942.5 , 998.7 }, { 72 , 1146.4 , 1335.95 , 1405.1 }, { 84 , 1563 , 1799.45 , 1889.25 }, { 96 , 2026.3 , 2338.3 , 2447.35 }, { 108 , 2573.35 , 2944.95 , 3078.25 }, { 120 , 3198.2 , 3622.8 , 3780 }, { 132 , 3891.65 , 4374.65 , 4556.7 }, { 144 , 4651.05 , 5220.6 , 5424.3 }, { 156 , 5460.7 , 6085.9 , 6326.55 }, { 168 , 6323.5 , 6927.75 , 7143.45 }, { 180 , 7338.45 , 8091.25 , 8382.65 }, { 13 , 63.3 , 73.1 , 77.05 }, { 26 , 187.25 , 217.3 , 231.15 }, { 39 , 369.2 , 434.4 , 461.35 }, { 52 , 628.35 , 725.2 , 765.6 }, { 65 , 944.8 , 1107.65 , 1169.75 }, { 78 , 1362.25 , 1565.25 , 1644.7 }, { 91 , 1847.6 , 2120.25 , 2220.4 }, { 104 , 2399.2 , 2741.1 , 2870.95 }, { 117 , 3053 , 3452.15 , 3606.5 }, { 130 , 3779.2 , 4247.55 , 4431.3 }, { 143 , 4561.9 , 5126.25 , 5332 }, { 156 , 5468.8 , 6121.85 , 6344.05 }, { 169 , 6437.45 , 7172.2 , 7431.7 }, { 182 , 7536.9 , 8339.3 , 8624.6 }, { 195 , 8661.5 , 9573.4 , 9890.9 }, { 14 , 75.4 , 85.1 , 90.2 }, { 28 , 214.7 , 253.6 , 266.25 }, { 42 , 433.2 , 508.65 , 534.8 }, { 56 , 735.75 , 854.1 , 901.1 }, { 70 , 1122.5 , 1283.65 , 1352.95 }, { 84 , 1584.6 , 1823.05 , 1912.95 }, { 98 , 2147.35 , 2455.75 , 2570.65 }, { 112 , 2794.55 , 3173.9 , 3321 }, { 126 , 3561.8 , 4003.65 , 4164.05 }, { 140 , 4399.5 , 4947.25 , 5140.65 }, { 154 , 5339.3 , 5945.2 , 6171.05 }, { 168 , 6356.2 , 7078.9 , 7331.45 }, { 182 , 7509.7 , 8310.65 , 8577.1 }, { 196 , 8760.05 , 9642.95 , 9971.45 }, { 210 , 10097.9 , 11104.1 , 11441.9 }, { 15 , 82.75 , 97.3 , 103.45 }, { 30 , 247.4 , 287.3 , 309.35 }, { 45 , 504.7 , 582 , 613.6 }, { 60 , 847.2 , 979.2 , 1031.1 }, { 75 , 1292.15 , 1479.3 , 1560.25 }, { 90 , 1837.05 , 2097.7 , 2190.85 }, { 105 , 2482.05 , 2825 , 2948.95 }, { 120 , 3239.3 , 3662.25 , 3814.5 }, { 135 , 4095.6 , 4596.6 , 4779.7 }, { 150 , 5073.8 , 5672.75 , 5881.65 }, { 165 , 6165.45 , 6861.8 , 7110 }, { 180 , 7380.15 , 8145.9 , 8431.65 }, { 195 , 8685.6 , 9563.25 , 9881.75 }, { 210 , 10107 , 11095.4 , 11431.4 }, { 225 , 11633.8 , 12725.2 , 13133.1 }  
};

char a[LIMIT][LIMIT],State[LIMIT][LIMIT][LIMIT];
int ar1[LIMIT][LIMIT],ar2[LIMIT][LIMIT],ar3[LIMIT][LIMIT],ar4[LIMIT][LIMIT],n,m,k;
unordered_map<ll,bool> rem;
ll five[100],g31,g32,t7[100],arry[2*LIMIT];
ll fin[LIMIT][LIMIT];

inline void printa(){
    for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
                putchar_unlocked(a[i][j]);
            putchar_unlocked('\n');
        }
}

inline ll cv(char c){
    switch(c){case 'A':return 1;break;case 'G':return 2;break;case 'C':return 3;break;case 'T':return 4;}
    return 555;
}

inline ll modpow(ll base, ll exponent)
{
    ll ansult = 1;
    while (exponent>0){
        if (exponent % 2 == 1)ansult = (ansult * base)%mod;
        exponent = exponent >> 1;
        base = (base * base)%mod;
    }
    return ansult;
}

inline void ct(){
    int ac1,ac2,ac3,ac4;
    for (int i = 1; i <= n; ++i){
        ac4=ac1=ac2=ac3=0;
        for (int j = 1; j <= m; ++j)
        {
            switch(a[i][j]){case 'A': ac1++;break;case 'G': ac2++;break;case 'C': ac3++;break;case 'T': ac4++;}
            ar4[i][j]=ar4[i-1][j]+ac4;ar3[i][j]=ar3[i-1][j]+ac3;
            ar2[i][j]=ar2[i-1][j]+ac2;ar1[i][j]=ar1[i-1][j]+ac1;
        }
    }
}

inline void ct2(int x){
    int ac1,ac2,ac3,ac4;
    for (int i = 1; i <= n; ++i){
        ac4=ac1=ac2=ac3=0;
        for (int j = 1; j <= m; ++j)
        {
            switch(State[x][i][j]){case 'A': ac1++;break;case 'G': ac2++;break;case 'C': ac3++;break;case 'T': ac4++;}
            ar4[i][j]=ar4[i-1][j]+ac4;ar3[i][j]=ar3[i-1][j]+ac3;
            ar2[i][j]=ar2[i-1][j]+ac2;ar1[i][j]=ar1[i-1][j]+ac1;
        }
    }
}

inline void pre(){
    g31=(modpow(31,m)*ll(m))%mod;
    g32=(modpow(31,3*n)*ll(n))%mod;
    rem.clear();
    for (int i = 0; i < LIMIT ; ++i)
        fin[0][i]=fin[i][0]=0;
    for (int i = 1; i <= n; ++i){
        ll accu=0;
        ll term=t7[i-1];
        for (int j = 1; j <= m; ++j){
            accu+=five[j-1]*cv(a[i][j]);
            fin[i][j]=fin[i-1][j] + accu*term;
        }
    }
}

inline void pre2(int x){
    g31=(modpow(31,m)*ll(m))%mod;
    g32=(modpow(31,3*n)*ll(n))%mod;
    rem.clear();
    for (int i = 0; i < LIMIT ; ++i)
        fin[0][i]=fin[i][0]=0;
    for (int i = 1; i <= n; ++i){
        ll accu=0;
        ll term=t7[i-1];
        for (int j = 1; j <= m; ++j){
            accu+=five[j-1]*cv(State[x][i][j]);
            fin[i][j]=fin[i-1][j] + accu*term;
        }
    }
}

inline ll hash1(int xt,int yt,int xl,int yl){
    ll of=ll(xl)*g31 + ll(yl)*g32;
    ll ans=(fin[xt+xl-1][yl+yt-1]+fin[xt-1][yt-1]-fin[xt-1][yl+yt-1]-fin[xt+xl-1][yt-1])/five[yt-1];
    return of + ans/t7[xt-1];
}

void gen1(int v){
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            a[i][j]=c[rand()%v];
}

void gen2(int s1, int v){
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            State[s1][i][j]=c[rand()%v];
}

void merge1(int s1,int s2,d prob){
    for (int i = 1; i <=n; ++i)
        for (int j = 1; j <=m; ++j)
            a[i][j]=d(rand())/d(RAND_MAX)<prob?State[s1][i][j]:State[s2][i][j];
}

void merge2(int s3, int s1,int s2,d prob){
    for (int i = 1; i <=n; ++i)
        for (int j = 1; j <=m; ++j)
            State[s3][i][j]=d(rand())/d(RAND_MAX)<prob?State[s1][i][j]:State[s2][i][j];
}

inline ll calc(){
    ct();
    if (ar1[n][m]==n*m)
        return n*m;
    pre();
    ll ans=0;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            for (int l = i; l <=n ; ++l)
                for (int v = j; v <=m ; ++v){
                    ll temp=hash1(i,j,l-i+1,v-j+1);
                    // if (temp<0)temp=-temp+(ll(1)<<62);
                    if (!rem[temp]){
                        rem[temp]=true;
                        ans++;
                    }
                }
    return ans;
}

inline ll calc3(int x){
    ct2(x);
    pre2(x);
    if (ar1[n][m]==n*m)
        return n*m;
    bitset<RANGE> my;
    ll ans=0;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            for (int l = i; l <=n ; ++l)
                for (int v = j; v <=m ; ++v){
                    ll temp=hash1(i,j,l-i+1,v-j+1)%RANGE;
                    if (temp<0)temp+=RANGE;
                    if (my[temp]==0){
                        my[temp]=1;
                        ans++;
                    }
                }
    return ans;
}

inline void incr(int x,int num,int v){
    for (int i = 1; i <=n; ++i)
        for (int j = 1; j <=m; ++j){
            if (State[x][i][j]=='A'){
                State[x][i][j]=c[v+rand()%(4-v)];
                num--;
            }
            if(num==0)return;
        }
}

inline void incr2(int x,int num,int v){
    for (int i = n; i>0; --i)
        for (int j = m; j>0; --j){
            if (State[x][i][j]=='A'){
                State[x][i][j]=c[v+rand()%(4-v)];
                num--;
            }
            if(num==0)return;
        }
}

int brute(int x){
    int ans=0;
    ct2(x);
    // if (ar1[n][m]==n*m)
    //  return n*m;
    for (int i = 1; i <=n; ++i)
    {
        for (int j = 1; j<=m; ++j)
        {
            for (int p=1; p <=n-i+1; ++p)
            {
                for (int q =1; q <=m-j+1; ++q)
                {
                    bool found=false;
                    for (int r = 1;!found and r<=i; ++r)
                    {
                        for (int s = 1; s<=m-q+1; ++s)
                        {
                            if (r==i and s>=j)break;
                            bool same=true;
                            for (int aa = 0;same and aa<p; ++aa)
                            {
                                for (int bb=0; bb<q; ++bb)
                                {
                                    if(State[x][i+aa][j+bb]!=State[x][r+aa][s+bb]){
                                        same=false;
                                        break;
                                    }
                                }
                            }
                            if(same){
                                found=true;
                                break;
                            }
                        }
                    }
                    if (!found){
                        ans++;
                    }
                }
            }
        }
    }
    return ans;
}

int main(){
    int t,j=0,i,l;
    srand (time(NULL)); 
    scanf("%d",&t);
    for ( i =five[0]=t7[0]= 1; i < 100; ++i){
        five[i]=five[i-1]*ll(5);
        t7[i]=t7[i-1]*ll(4);
    }
    while(t--){
        scanf("%d %d %d",&n,&m,&k);
        l=15*(n-1)+(m-1);
        int ind=0,ans=0;
        if (k<=vals[l][0]){
            gen1(1);
        }else if(k<=vals[l][1]){
            ans=vals[l][0];
            gen2(1,1);
            int iter=80,oldans=vals[l][0],iter2=1;
            d fac=d(k-ans)/k;
            while(iter-- and fac>0 ){
                int xtra=(k-ans>1000?2:0)+(k-ans>2000?5:0)+(k-ans>3000?8:0)+(k-ans>500?1:0);
                iter2=max(fac+xtra,1);
                if(rand()&1)incr2(1,iter2,1);
                else incr(1,iter2,1);
                oldans=ans;
                memcpy(State[2],State[1],sizeof(a));
                ans=iter%3==0?brute(1): calc3(1);
                fac=d(k-ans)/k;
            }
            memcpy(a,State[abs(k-oldans)<abs(k-ans)?2:1],sizeof(a));
        }else if (k<=vals[l][2]){
            ans=vals[l][1];
            gen2(1,2);
            int iter=40,oldans=vals[l][0],iter2=1;
            d fac=d(k-ans)/k;
            while(iter-- and fac>0 ){
                int xtra=(k-ans>1000?2:0)+(k-ans>2000?3:0);
                iter2=max(2*fac+xtra,1);
                if(rand()&1)incr2(1,iter2,2);
                else incr(1,iter2,2);
                oldans=ans;
                memcpy(State[2],State[1],sizeof(a));
                ans=iter%3==0?brute(1): calc3(1);
                fac=d(k-ans)/k;
            }
            memcpy(a,State[abs(k-oldans)<abs(k-ans)?2:1],sizeof(a));
        }else if(k<=vals[l][3]){
            ans=vals[l][1];
            gen2(1,3);
            int iter=30,oldans=vals[l][0],iter2=1;
            d fac=d(k-ans)/k;
            while(iter-- and fac>0 ){
                int xtra=(k-ans>1000?1:0)+(k-ans>2000?2:0);
                iter2=max(2*fac+xtra,1);
                if(rand()&1)incr2(1,iter2,2);
                else incr(1,iter2,2);
                oldans=ans;
                memcpy(State[2],State[1],sizeof(a));
                ans=iter%3==0?brute(1): calc3(1);
                fac=d(k-ans)/k;
            }
            memcpy(a,State[abs(k-oldans)<abs(k-ans)?2:1],sizeof(a));
        }
        else {
            gen1(4);
        }
        printa();
        
    }
    return 0;
}